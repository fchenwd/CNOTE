## [牛客小白月赛98](https://ac.nowcoder.com/acm/contest/85598)

### [C - 切割 01 串 2.0](https://ac.nowcoder.com/acm/contest/85598/D)

<image src='https://img.picui.cn/free/2024/07/17/6697ae544f9af.png' width='94%'/>

<br>

## 题意理解

给个 $n$ 长度的 $01$ 串，给两个数 $L$ $R$，将 $01$ 串分割成两个非空子串，左半子串中 $0$ 出现的个数为 $C_0$，右半子串中 $1$ 出现的个数为 $C_1$，要求满足 $L \leq |C_0 - C_1| \leq R$。求最多能切割多少次。

<br>

# 题解

### 区间DP

首先数据范围很小 $n=500$，并注意到数据范围甚至没到 $1e3$ 的数量级，说明 $O(n^3)$ 可能也能过。同时，这个题很明显可以 **DP**。

先用一般 **DP** 的思路思考一下，通过分割子问题法，大致会写个 `dp[n][n - 1]` 的这样一个数组，$i$ 枚举当前位置，$j$ 为枚举分割点。但实操起来会发现这样写 DP 多少会感觉很奇怪，因为这样写相当于只用 $i$ 枚举了右半边边界，并不满足题意。那么怎么 **同时枚举左半边和右半边** 呢？就要使用 **区间DP** 构造 $DP[L][R]$ 了。

**区间DP** 是要 **枚举合并点** 的，与本题 **枚举分割点** 的性质十分符合，故用区间DP其实是更好的选择，同时数据范围也明显满足区间DP的要求。

直接套板子即可，具体看代码实现

<br>

## 代码实现
```cpp
int L[N], R[N];
int dp[N][N];
void solve()
{
	int n, l, r; cin >> n >> l >> r;
	string a; cin >> a;
	a = ' ' + a;
    // 前缀和计算 左半0 的个数和 右半1 的个数
	fa(i, 1, n)L[i] = L[i - 1] + (a[i] == '0'); 
	fb(i, n, 1)R[i] = R[i + 1] + (a[i] == '1');
    // 区间DP板子
	fa(len, 2, n) {
		for (int i = 1; i <= n + 1 - len; i++) {
			int j = len + i - 1;
			fa(k, i, j - 1) { // 枚举合并点，并根据题意，设合并点为分割点
				int now = abs((L[k] - L[i - 1]) - (R[k + 1] - R[j + 1]));
				if (l <= now and now <= r) {
					dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + 1);
				}
			}
		}
	}
	cout << dp[1][n] << endl;
	return;
}
```